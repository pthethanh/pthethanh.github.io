<!doctype html>
<html lang="en" domain="https://thefortunedays.com" v-scope="app">
<head><base href="/"><meta charset="utf-8"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="keywords" content="golang string concatenation performance comparison,golang concatenation performance,string join performance,golang string builder,golang,thanh pham golang,&amp;nbsp;pthethanh.herokuapp.com"><meta name="author" content="Thanh Pham"><meta name="image" content="/static/images/articles/golang-string-concat-performance/concat-worg.jpg"><meta name="description" content="strings.Builder gives very good performance in general, but we can improve it even better."><meta property="og:url" content="https://thefortunedays.com/articles/golang-string-concatenation-performance"><meta property="og:title" content="Go String Concat Performance"><meta property="og:type" content="article"><meta property="og:image" content="/static/images/articles/golang-string-concat-performance/concat-worg.jpg"><meta property="og:description" content="strings.Builder gives very good performance in general, but we can improve it even better."><meta property="og:locale" content="en_GB"><meta name="twitter:card" content="summary_large_image"><title>Go String Concat Performance</title><link rel="canonical" href="https://thefortunedays.com/articles/golang-string-concatenation-performance"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="preconnect" href="/" crossorigin><link rel="icon" type="image/png" sizes="32x32" href="/static/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/static/images/favicon-16x16.png"><link rel="apple-touch-icon" href="/static/images/favicon-32x32.png"><link href="/static/css/index.css" rel="stylesheet" rel="preload" as="style"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&family=Spectral&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&family=Spectral&display=swap" media="print" onload="this.media='all'"><noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro&family=Spectral&display=swap"></noscript><script async defer="defer" src="https://unpkg.com/petite-vue@0.4.1/dist/petite-vue.iife.js"></script><script async defer="defer" src="https://cdn.jsdelivr.net/npm/js-cookie@rc/dist/js.cookie.min.js"></script><script async defer="defer" src="/static/js/index.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-9X9G2YCR2X"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-9X9G2YCR2X');</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4025327352745846" crossorigin="anonymous"></script></head>
<body class="min-h-screen body" id="app"><header id="header" class="sticky z-50 bg-white"><nav class="flex justify-between px-2 lg:px-5 py-4 border-b border-gray-100 font-serif"><a href="/" class="flex space-x-2 items-center"><svg version="1.2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2048 2048" class="h-8 w-8"><title>The Fortune Days</title><style>.s1 { fill:black;stroke: url(#g1);stroke-width: 0;stroke-dasharray: 0,0 } 
          .s2 { fill:black;stroke: url(#g2);stroke-width: 0;stroke-dasharray: 0,0 } 
          .s3 { fill:black;stroke: url(#g3);stroke-width: 0;stroke-dasharray: 0,0 } 
          .s4 { fill:black;stroke: url(#g4);stroke-width: 0;stroke-dasharray: 0,0 }</style><g id="logo"><g id="logo"><path id="bk" fill-rule="evenodd" class="s1" d="m1090.5 1071.3l111.5 189.6 232.5-3.8-194.1-332 65.7-113.7 335 575h-501l-119.9-207.3-69.8-120.7-220.2 1.5-113 202.9 385.1-1.9 72.6 125.5h-666.9l257.8-442.6h229.3 139.7l108.8-191.1-119.6-199.1-190.9 333.8h-134.4l325.8-559.4 248.9 427.2-113 195.3z"/><path id="Rectangle 2 copy 3" fill-rule="evenodd" class="s2" d="m950.4 1058.4l-220.2 1.5-113 202.9 385.1-1.9 72.6 125.5h-666.9l257.8-442.6h229.3 139.7z"/><path id="Rectangle 2 copy 4" fill-rule="evenodd" class="s3" d="m1090.5 1071.3l111.5 189.6 232.5-3.8-194.1-332 65.7-113.7 335 575h-501l-119.9-207.3-69.8-120.7z"/><path id="Rectangle 2 copy 5" fill-rule="evenodd" class="s4" d="m1090.5 1071.3l-55.7-127.5 108.8-191.1-119.6-199.1-190.9 333.8h-134.4l325.8-559.4 248.9 427.2-113 195.3z"/></g></g></svg><div :class="showMenu ? 'hidden md:block font-semibold': 'font-semibold'" v-cloak>THE FORTUNE DAYS</div></a><div class="flex space-x-5 md:space-x-8 items-center"><div class="flex space-x-2 text-sm md:text-base" v-show="showMenu" v-cloak><a class="transition duration-500 ease-in-out" href="/">Home</a> <a class="transition duration-500 ease-in-out" href="/articles">Articles</a> <a class="transition duration-500 ease-in-out" href="/about">About</a></div><svg @click="showMenu=!showMenu" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="h-6 w-6 cursor-pointer"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"/></svg></div></nav></header><div class="w-full pb-14"><div class="container w-full max-w-xl mx-auto px-2 pb-10">
    <article class="w-full pt-10 md:pt-14 pb-5">
      <div class="w-full mb-10">
        <h1 class="mb-2 text-3xl lg:text-4xl font-serif font-semibold">Go String Concat Performance</h1>
        <div class="flex justify-between">
          <div class="text-sm lg:text-base font-medium text-gray-600">Thanh Pham / Mon 10 Apr 2023</div>
          <div class="flex space-x-2"></div>
        </div>
      </div>
      <div class="prose prose-img:mb-2 lg:prose-lg prose-img:lg:mb-2 font-serif text-justify">
        <div><div class="text-xs lg:text-sm font-sans mb-5 mt-5"><span class="font-bold pr-2">Summary.</span>strings.Builder gives very good performance in general, but we can improve it even better.</div><picture class="object-center object-cover w-full"><source sizes="50vw" srcset="/static/images/articles/golang-string-concat-performance/concat-w160.webp w160,/static/images/articles/golang-string-concat-performance/concat-w320.webp w320,/static/images/articles/golang-string-concat-performance/concat-w640.webp w640,/static/images/articles/golang-string-concat-performance/concat-w1280.webp w1280" type="webp"><img width="359" height="240" class="object-center object-cover bg-none w-full" src="/static/images/articles/golang-string-concat-performance/concat-worg.jpg" alt="Go string concatenation performance comparison" style='background-image: url("data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACQAQCdASoIAAYAAgA0JaQAAp208KAA/v3CvV5816jvzW7gTcAAAA==");background-repeat: no-repeat; background-size: cover'></picture><div class="w-full text-left text-captions font-sans text-xs">Go string concatenation performance comparison</div><p>String concatenation is a basic task that I often do as a developer, but I have never considered much about its performance. This article is a result of my curiosity about this topic.</p><h3>Navie</h3><p>The very normal approach that I often took when I first started with Go was to use a naive concatenation like this:</p><pre><code>func concatNaive(ss ...string) string {
	rs := ss[0]
	for i := 1; i &lt; len(ss); i&#43;&#43; {
		rs &#43;= ss[i] // cause memory allocation
	}
	return rs
}</code></pre><p>But this approach gives the worst performance. The statement `rs += ss[i]` will allocate new memory each time it is called. And we all know that allocation reduces the performance of function calls. Hence, we have to avoid it as much as we can.</p><p>The simple way to avoid multiple allocations is to allocate them in advance and make sure we allocate enough memory to avoid any additional allocations during the function calls. I came up with another brilliant idea, where I allocate the memory in advance and assign it byte by byte:</p><pre><code>func concatAssignIndex(ss ...string) string {
	length := len(ss)
	if length == 0 {
		return &#34;&#34;
	}
	// create &amp; allocate the memory in advance.
	n := 0
	for i := 0; i &lt; length; i&#43;&#43; {
		n &#43;= len(ss[i])
	}
	b := make([]byte, n, n)
	idx := 0
	for i := 0; i &lt; length; i&#43;&#43; {
		for j := 0; j &lt; len(ss[i]); j&#43;&#43; {
			b[idx] = ss[i][j]
			idx&#43;&#43;
		}
	}
	return string(b)
}
</code></pre><p>I thought it should be great, but this turns out to be another naive solution. You can see the nested loops that cause the big performance issue in the above block of code.</p><p>So, I gave up and tried one of the solutions recommended by most people in the community, `strings.Builder`.</p><h3>String Builder</h3><p>`strings.Builder` maintains an underlying byte buffer and exposes the `Grow(int)` method so that we can use it to grow the underlying buffer. The code using the string builder will look like this:</p><pre><code>func concatStringBuilder(ss ...string) string {
	length := len(ss)
	if length == 0 {
		return &#34;&#34;
	}
	b := strings.Builder{}
	// calculate the buffer size
	n := len(ss[0])
	for i := 1; i &lt; length; i&#43;&#43; {
		n &#43;= len(ss[i])
	}
	// grow the buffer to avoid memory allocation during writing new string.
	b.Grow(n)
	for i := 0; i &lt; length; i&#43;&#43; {
		b.WriteString(ss[i])
	}
	return b.String()
}</code></pre><p>Based on my testing, the `strings.Builder` gives very good performance and should be used in general cases. But one thing to notice when using strings.Builder is that you have to calculate the buffer size and grow it accordingly. Otherwise, the buffer will need to grow more and more during the function call, which will slow it down.</p><p>I doubt if it's true that strings.Builder is the best one. I think we can improve it even further. Let's see how strings.Builder is implemented.</p><h3>Improved String Builder</h3><p>If we look at the&nbsp;<a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20.3:src/strings/builder.go;l=76-92">implementation</a> of the strings.Builder, we can see that it maintains a slice of bytes, using `make` with capacity to allocate memory in advance and `append` to append the string to the buffer:</p><pre><code>// grow copies the buffer to a new, larger buffer so that there are at least n
// bytes of capacity beyond len(b.buf).
func (b *Builder) grow(n int) {
	buf := make([]byte, len(b.buf), 2*cap(b.buf)&#43;n)
	copy(buf, b.buf)
	b.buf = buf
}

// WriteString appends the contents of s to b&#39;s buffer.
// It returns the length of s and a nil error.
func (b *Builder) WriteString(s string) (int, error) {
	b.copyCheck()
	b.buf = append(b.buf, s...)
	return len(s), nil
}</code></pre><p>This piece of code looks so good, and we can learn from it to make our own version. In our case, we don't really need `b.copyCheck()` as we have a function instead of a method of a struct. We can eliminate this check and have a simple function like the one below, similar to what the strings.Builder tries to do:</p><pre><code>func concatFast(ss ...string) string {
	length := len(ss)
	if length == 0 {
		return &#34;&#34;
	}
	n := 0
	for i := 0; i &lt; length; i&#43;&#43; {
		n &#43;= len(ss[i])
	}
	// create &amp; allocate the memory in advance.
	b := make([]byte, 0, n)
	for i := 0; i &lt; length; i&#43;&#43; {
		b = append(b, ss[i]...)
	}
	// below statement causes a memory allocation.
	return string(b)
}</code></pre><p>The above function looks good, as we calculated and allocated the buffer to the exact size of the output string, but there's still a problem. The last statement, `string(b)` causes a memory allocation and hence reduces the performance of the function call. Let's see the benchmark below, the concatFast has 2 allocations instead of 1, and its performance is slower than the strings.Builder:</p><pre><code>goos: windows
goarch: amd64
pkg: github.com
cpu: 12th Gen Intel(R) Core(TM) i7-1255U
BenchmarkSmall/concat_fast_using_append__________-12             8743449               148.8 ns/op           576 B/op          2 allocs/op
BenchmarkSmall/concat_string_builder_____________-12            12188716                95.24 ns/op          288 B/op          1 allocs/op
</code></pre><p>Is there any way to avoid that allocation? You might wonder! Yes, there is a way to avoid that allocation by using `unsafe` package, and this is exactly the way strings.Builder does:</p><pre><code>func (b *Builder) String() string {
	return unsafe.String(unsafe.SliceData(b.buf), len(b.buf))
}</code></pre><p>This hack is pretty cool, and we can apply it to our function, the improved version would look like this:</p><pre><code>func concatFastImproved(ss ...string) string {
	length := len(ss)
	if length == 0 {
		return &#34;&#34;
	}
	// create &amp; allocate the memory in advance.
	n := 0
	for i := 0; i &lt; length; i&#43;&#43; {
		n &#43;= len(ss[i])
	}
	b := make([]byte, 0, n)
	for i := 0; i &lt; length; i&#43;&#43; {
		b = append(b, ss[i]...)
	}
	return unsafe.String(unsafe.SliceData(b), n)
}</code></pre><p>The above method looks pretty good and gives better performance compared to strings.Builder. An alternative to `append` is `copy`, and it would give a similar performance. Up to now, this has been the fastest solution so far.</p><p>One lesson I learn from this is that it's always a good idea to use built-in functions like `copy` and `append` as much as we can. And by talking about built-in, I wonder if the solution of using the concatenation operator would give a similar performance.</p><h3>+ Operator</h3><p>This is one of the simplest solutions ever. Just do `s[0] + s[2] + s[3]+ ... + s[n]` and we can have what we want. This solution gives a very good performance, which is similar to our improved version of strings.Builder. </p><p>I think the reason is because the way Go runtime also uses `copy` in its <a href="https://go.dev/src/runtime/string.go#L20">implementation</a>, but it seems its optimization is just for strings with length &lt;= <a href="https://go.dev/src/runtime/string.go#L14">32</a>, so if our string is longer than that, the optimization seems not to be applied.</p><p> But notice that the challenge when you want to use this approach is that you have to know the length of the slice in advance. I think usage of this is limited.</p><h3>Other solutions?</h3><p>Other solutions, including `fmt.Sprintf` or using `bytes.Buffer` give much worse performance than our improved version of string builder. But maybe there are still a lot of other solutions that I don't know yet.</p><h3>The code and the benchmark</h3><p>I tested all the approaches with small, medium, and big slices with lengths of 10, 100, and 10,000 respectively to see the differences, and the winner is our improved version of strings.Builder.</p><p>You can see the code here in the <a href="https://gist.github.com/pthethanh/e7624f54d98633c3e7f0c71415a253b1">gist</a>. And below is the benchmark:</p><pre><code>goos: windows
goarch: amd64
pkg: github.com
cpu: 12th Gen Intel(R) Core(TM) i7-1255U
BenchmarkSmall/concat_naive______________________-12             2725071               449.6 ns/op          1520 B/op          9 allocs/op
BenchmarkSmall/concat_string_builder_without_grow-12             3993370               287.7 ns/op           984 B/op          5 allocs/op
BenchmarkSmall/concat_assign_index_______________-12             4681068               255.5 ns/op           288 B/op          1 allocs/op
BenchmarkSmall/concat_bytes_buffer_______________-12             6646387               179.3 ns/op           576 B/op          2 allocs/op
BenchmarkSmall/concat_fast_using_append__________-12             8743449               148.8 ns/op           576 B/op          2 allocs/op
BenchmarkSmall/concat_string_builder_____________-12            12188716                95.24 ns/op          288 B/op          1 allocs/op
BenchmarkSmall/concat_&#43;_operator_________________-12            11912088                96.59 ns/op          288 B/op          1 allocs/op
BenchmarkSmall/concat_fast_improved______________-12            13002703                90.33 ns/op          288 B/op          1 allocs/op
BenchmarkSmall/concat_fast_improved_using_copy___-12            14131878                97.54 ns/op          288 B/op          1 allocs/op

BenchmarkMedium/concat_naive______________________-12              14560             82115 ns/op          509697 B/op         98 allocs/op
BenchmarkMedium/concat_string_builder_without_grow-12             172482              5974 ns/op           34240 B/op         12 allocs/op
BenchmarkMedium/concat_assign_index_______________-12             130524              8269 ns/op            9472 B/op          1 allocs/op
BenchmarkMedium/concat_bytes_buffer_______________-12             447615              2940 ns/op           18944 B/op          2 allocs/op
BenchmarkMedium/concat_fast_using_append__________-12             376473              2819 ns/op           18944 B/op          2 allocs/op
BenchmarkMedium/concat_string_builder_____________-12             655304              1619 ns/op            9472 B/op          1 allocs/op
BenchmarkMedium/concat_&#43;_operator_________________-12             746950              1637 ns/op            9472 B/op          1 allocs/op
BenchmarkMedium/concat_fast_improved______________-12             749499              1613 ns/op            9472 B/op          1 allocs/op
BenchmarkMedium/concat_fast_improved_using_copy___-12             864777              1623 ns/op            9472 B/op          1 allocs/op

BenchmarkBig/concat_naive______________________-12                     2         745434800 ns/op        4995658496 B/op    10072 allocs/op
BenchmarkBig/concat_string_builder_without_grow-12                  1558            901401 ns/op         5241548 B/op         30 allocs/op
BenchmarkBig/concat_assign_index_______________-12                  1155            941113 ns/op          999430 B/op          1 allocs/op
BenchmarkBig/concat_bytes_buffer_______________-12                  2985            438088 ns/op         1998854 B/op          2 allocs/op
BenchmarkBig/concat_fast_using_append__________-12                  2904            444509 ns/op         1998854 B/op          2 allocs/op
BenchmarkBig/concat_string_builder_____________-12                  4792            245516 ns/op          999429 B/op          1 allocs/op
BenchmarkBig/concat_fast_improved______________-12                  4142            242516 ns/op          999429 B/op          1 allocs/op
BenchmarkBig/concat_fast_improved_using_copy___-12                  4478            260349 ns/op          999430 B/op          1 allocs/op
PASS
ok      github.com        39.751s</code></pre><h3>Lessons Learn</h3><p>I think there are a couple of things we can learn from this:</p><ul><li>Avoid memory allocation as much as we can.</li><li>Whenever a slice is used, try to allocate enough memory for it in advance.</li><li>Take advantage of built-in functions like `append`, `copy`,...</li><li>Sometimes `unsafe` package can provide some pretty good hacks for better performance, but they should be used with care. </li><li>Try to run benchmarks with multiple cases, small, medium, and large inputs to see the differences and improve the code from there.</li><li>There are a lot of things we can learn from the Go SDK, like strings.Builder in this case.</li><li>Explore the SDK code is a good way to learn and be a better Gopher.</li></ul></div>
      </div>
    </article><div class="flex justify-between pt-4 pb-10 border-t border-default font-sans">
    <a aria-label="Post To FaceBook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fthefortunedays.com%2farticles%2fgolang-string-concatenation-performance" class="flex flex-col items-center">
      <svg class="h-6 w-6" fill="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
        <path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"></path>
      </svg>
      <span>Post</span>
    </a>
    <a aria-label="Tweet It" href="https://twitter.com/share?url=https%3a%2f%2fthefortunedays.com%2farticles%2fgolang-string-concatenation-performance&text=String%20concatenation%20performance%20comparison" class="flex flex-col items-center">
      <svg class="h-6 w-6" fill="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24">
        <path d="M23 3a10.9 10.9 0 01-3.14 1.53 4.48 4.48 0 00-7.86 3v1A10.66 10.66 0 013 4s-4 9 5 13a11.64 11.64 0 01-7 2c9 5 20 0 20-11.5a4.5 4.5 0 00-.08-.83A7.72 7.72 0 0023 3z"></path>
      </svg>
      <span>Tweet</span>
    </a>
    <a aria-label="Share on LinkedIn" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2fthefortunedays.com%2farticles%2fgolang-string-concatenation-performance" class="flex flex-col items-center">
      <svg class="h-6 w-6" fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="0" viewBox="0 0 24 24">
        <path stroke="none" d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6zM2 9h4v12H2z"></path>
        <circle cx="4" cy="4" r="2" stroke="none"></circle>
      </svg>
      <span>Share</span>
    </a>
  </div><div class="flex flex-col md:flex-row py-8  border-t border-b border-default font-serif">
      <div class="flex md:flex-col w-full md:w-1/5">
        <div class="font-sans">Next In</div>
        <a aria-label="More on this tag" href="/articles/tags/golang" class="font-bold capitalize ml-2 md:mt-2 md:ml-0">golang</a>
      </div>
      <div class="hidden md:flex border-l border-default px-1"></div>
      <div class="w-full md:w-4/5 flex flex-col-reverse md:flex-row">
        <div class="w-full md:w-1/2 mt-2 md:mt-0">
          <a href="/articles/go-map-hash" class="font-semibold capitalize">Go Map Hash</a>
          <p class="mt-2 line-clamp-3 font-serif">How to implement hash code in Go</p>
        </div>
        <a aria-label="Next article" class="mt-2 md:pl-2 md:mt-0 md:w-1/2" href="/articles/go-map-hash">
          <img decoding="async" loading="lazy" width="240" height="120" class="object-cover object-center w-ful" src="/static/images/articles/go-map-hash/go-map-hash.gif" alt="Hash Function" />
        </a>
      </div>
    </div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
  <script>hljs.highlightAll();</script></div></div><footer class="flex w-full font-light justify-center border-t border-gray-100 align-middle"><div class="text-xs text-gray-500 py-8 font-sans">Copyright © 2020 - Thanh Pham. All rights reserved.</div></footer><script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "name":"Go String Concat Performance",
      "headline":"Go String Concat Performance",
      "identifier":"golang-string-concatenation-performance",
      "keywords":"golang string concatenation performance comparison,golang concatenation performance,string join performance,golang string builder,golang,thanh pham golang,\u0026nbsp;pthethanh.herokuapp.com",
      "image": [],
      "author":"Thanh Pham",
      "genre": "",
      "publisher": {
        "@type": "Organization",
        "name":"The Fortune Days",
        "logo": {
          "@type": "ImageObject",
          "url":"https://thefortunedays.com/static/images/favicon.ico"}
      },
      "url":"https://thefortunedays.com/articles/golang-string-concatenation-performance",
      "mainEntityOfPage":"https://thefortunedays.com",
      "datePublished":{"seconds":1681014911,"nanos":358000000},
      "dateModified":{},
      "description":"strings.Builder gives very good performance in general, but we can improve it even better."}
  </script></body>
</html>
